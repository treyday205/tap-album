import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Loader2, LogOut, Plus, ShieldCheck } from 'lucide-react';
import AlbumCard from '../components/AlbumCard';
import { StorageService } from '../services/storage';
import { Api } from '../services/api';
import { Project, User } from '../types';
import { isAssetRef, resolveAssetUrl } from '../services/assets';
import { collectBankRefs, resolveBankUrls } from '../services/assetBank';

const LEGACY_DEFAULT_COVER_URL = 'https://images.unsplash.com/photo-1614613535308-eb5fbd3d2c17?auto=format&fit=crop&q=80&w=800';
const AUTO_GENERATED_TITLE = 'New Album';
const getAdminToken = () => localStorage.getItem('tap_admin_token') || undefined;
const isLegacyDefaultCover = (value?: string | null) =>
  String(value || '').trim() === LEGACY_DEFAULT_COVER_URL;
const isAutoGeneratedGhostProject = (project: Project, trackCount?: number) => {
  const title = String(project.title || '').trim();
  if (title !== AUTO_GENERATED_TITLE) return false;
  const count = Number.isFinite(Number(trackCount)) ? Number(trackCount) : null;
  if (count !== null && count !== 0) return false;
  const cover = String(project.coverImageUrl || '').trim();
  return isLegacyDefaultCover(cover);
};
const sanitizeProjectCover = (project: Project): Project => {
  if (!isLegacyDefaultCover(project.coverImageUrl)) {
    return project;
  }
  return {
    ...project,
    coverImageUrl: '',
    coverPath: null,
    coverSignedUrl: null
  };
};
const hasCoverReference = (project: Project) => {
  const cover = String(project.coverImageUrl || '').trim();
  if (!cover) return false;
  return !isLegacyDefaultCover(cover);
};
const CreateAlbumPlaceholderCard: React.FC<{ onCreate: () => void; loading?: boolean }> = ({
  onCreate,
  loading = false
}) => (
  <button
    type="button"
    onClick={onCreate}
    disabled={loading}
    className="group relative bg-slate-900/50 border-2 border-dashed border-slate-800 hover:border-green-500 rounded-3xl overflow-hidden transition-all text-left disabled:cursor-wait disabled:opacity-80"
  >
    <div className="aspect-square w-full relative overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-br from-slate-900 to-slate-800 flex flex-col items-center justify-center text-slate-500">
        {loading ? <Loader2 size={30} className="animate-spin text-slate-500" /> : <ShieldCheck size={30} />}
        <p className="mt-3 text-[10px] font-black uppercase tracking-widest text-slate-600">No Cover</p>
      </div>
      <div className="absolute top-4 right-4 flex gap-2">
        <span className="text-[10px] font-black px-2 py-1 rounded border uppercase bg-slate-800 text-slate-300 border-slate-700">
          Draft
        </span>
      </div>
    </div>
    <div className="p-6">
      <h3 className="text-xl font-bold mb-1 truncate text-white">
        {loading ? 'Loading Albums...' : 'Create New Album'}
      </h3>
      <p className="text-slate-400 text-[10px] font-bold uppercase tracking-widest mb-6 flex items-center gap-1 opacity-50">
        <Plus size={10} />
        UI Placeholder
      </p>
      <div className="flex items-center justify-center gap-2 bg-green-500 hover:bg-green-400 text-black font-bold py-2.5 rounded-xl transition-colors">
        <Plus size={14} />
        Create Private TAP
      </div>
    </div>
  </button>
);

const DashboardPage: React.FC = () => {
  const navigate = useNavigate();
  const [user, setUser] = useState<User | null>(null);
  const [projects, setProjects] = useState<Project[]>([]);
  const [assetUrls, setAssetUrls] = useState<Record<string, string>>({});
  const [projectsLoading, setProjectsLoading] = useState(true);
  const [isCreatingProject, setIsCreatingProject] = useState(false);
  const [deletingProjectId, setDeletingProjectId] = useState<string | null>(null);

  useEffect(() => {
    const currentUser = StorageService.getCurrentUser();
    setUser(currentUser);
    const localTrackCount = (projectId: string) => StorageService.getTracks(projectId).length;
    const readLocalProjects = () => {
      const raw = StorageService.getProjects().map((project) => sanitizeProjectCover(project));
      const cleaned = raw.filter((project) => !isAutoGeneratedGhostProject(project, localTrackCount(project.projectId)));
      const validIds = new Set(cleaned.map((project) => project.projectId));
      raw.forEach((project) => {
        if (!validIds.has(project.projectId)) {
          StorageService.deleteProject(project.projectId);
        }
      });
      cleaned.forEach((project) => StorageService.saveProject(project));
      return cleaned;
    };

    const syncLocalProjects = (nextProjects: Project[]) => {
      const current = StorageService.getProjects();
      const nextIds = new Set(nextProjects.map((project) => project.projectId));
      current.forEach((project) => {
        if (!nextIds.has(project.projectId)) {
          StorageService.deleteProject(project.projectId);
        }
      });
      nextProjects.forEach((project) => StorageService.saveProject(project));
    };

    const hydrateProjectsFromApi = async () => {
      readLocalProjects();
      try {
        const response = await Api.getProjects(getAdminToken());
        const remoteProjectsRaw = Array.isArray(response?.projects) ? response.projects : [];
        const remoteProjects = remoteProjectsRaw
          .map((project: Project) => sanitizeProjectCover(project))
          .filter((project: any) => {
            const count = Number(project?.trackCount);
            return !isAutoGeneratedGhostProject(project, Number.isFinite(count) ? count : undefined);
          });
        const coverUpdates: Record<string, string> = {};
        remoteProjects.forEach((project: any) => {
          const ref = String(project?.coverImageUrl || '').trim();
          const signed = String(project?.coverSignedUrl || '').trim();
          if (isAssetRef(ref) && signed) {
            coverUpdates[ref] = signed;
          }
        });
        setProjects(remoteProjects);
        if (Object.keys(coverUpdates).length > 0) {
          setAssetUrls((prev) => ({ ...prev, ...coverUpdates }));
        }
        syncLocalProjects(remoteProjects);
      } catch (err) {
        setProjects([]);
        if (import.meta.env.DEV) {
          console.warn('[DEV] projects hydrate failed', err);
        }
      } finally {
        setProjectsLoading(false);
      }
    };

    void hydrateProjectsFromApi();
  }, []);

  useEffect(() => {
    const signCovers = async () => {
      const updates: Record<string, string> = {};
      for (const project of projects) {
        if (!isAssetRef(project.coverImageUrl)) continue;
        if (assetUrls[project.coverImageUrl]) continue;
        try {
          const token = getAdminToken();
          const response = await Api.signAssets(project.projectId, [project.coverImageUrl], token);
          (response.assets || []).forEach((asset: any) => {
            if (asset?.ref && asset?.url) {
              updates[asset.ref] = asset.url;
            }
          });
        } catch (err) {
          if (import.meta.env.DEV) {
            console.warn('[DEV] cover signing failed', err);
          }
        }
      }
      if (Object.keys(updates).length > 0) {
        setAssetUrls(prev => ({ ...prev, ...updates }));
      }
    };

    if (projects.length > 0) {
      signCovers();
    }
  }, [projects, assetUrls]);

  useEffect(() => {
    const hydrateBankCovers = async () => {
      const refs = collectBankRefs(projects.map((project) => project.coverImageUrl));
      const missing = refs.filter((ref) => !assetUrls[ref]);
      if (missing.length === 0) return;
      try {
        const resolved = await resolveBankUrls(missing);
        if (Object.keys(resolved).length > 0) {
          setAssetUrls((prev) => ({ ...prev, ...resolved }));
        }
      } catch (err) {
        if (import.meta.env.DEV) {
          console.warn('[DEV] bank cover hydration failed', err);
        }
      }
    };

    if (projects.length) {
      hydrateBankCovers();
    }
  }, [projects, assetUrls]);

  const resolveAsset = (value: string) => resolveAssetUrl(value, assetUrls);

  const resolveCoverSrc = (project: Project) => {
    const cover = String(project.coverImageUrl || '').trim();
    if (!cover) return '';
    if (isLegacyDefaultCover(cover)) return '';
    return resolveAsset(cover);
  };

  const retryCoverUrl = async (project: Project): Promise<string | null> => {
    const coverRef = String(project.coverImageUrl || '').trim();
    if (!coverRef) return null;
    if (isLegacyDefaultCover(coverRef)) return null;

    if (!isAssetRef(coverRef)) {
      const resolved = resolveAsset(coverRef);
      return resolved || null;
    }

    try {
      const token = getAdminToken();
      const response = await Api.getProjectCoverUrl(project.projectId, token);
      const signed = String(response?.coverSignedUrl || '').trim();
      if (signed) {
        setAssetUrls((prev) => ({ ...prev, [coverRef]: signed }));
        return signed;
      }
    } catch (err) {
      if (import.meta.env.DEV) {
        console.warn('[DEV] cover retry url fetch failed', err);
      }
    }

    try {
      const token = getAdminToken();
      const response = await Api.signAssets(project.projectId, [coverRef], token);
      const signed = response?.assets?.[0]?.url ? String(response.assets[0].url) : '';
      if (signed) {
        setAssetUrls((prev) => ({ ...prev, [coverRef]: signed }));
        return signed;
      }
    } catch (err) {
      if (import.meta.env.DEV) {
        console.warn('[DEV] cover retry sign failed', err);
      }
    }

    return null;
  };

  const handleLogout = () => {
    localStorage.removeItem('tap_is_admin');
    localStorage.removeItem('tap_admin_token');
    navigate('/admin');
  };

  const upsertProject = (nextProject: Project) => {
    setProjects((prev) => {
      const next = [...prev];
      const index = next.findIndex((project) => project.projectId === nextProject.projectId);
      if (index >= 0) {
        next[index] = nextProject;
      } else {
        next.unshift(nextProject);
      }
      return next.sort(
        (a, b) =>
          new Date(String(b.updatedAt || 0)).getTime() - new Date(String(a.updatedAt || 0)).getTime()
      );
    });
  };

  const handleCreateNew = async () => {
    if (isCreatingProject) return;
    setIsCreatingProject(true);
    try {
      const token = getAdminToken();
      const response = await Api.createProject(
        {
          ownerUserId: user?.userId || 'u1',
          artistName: user?.displayName || 'Artist Name'
        },
        token
      );
      const createdProject = sanitizeProjectCover(response?.project as Project);
      if (!createdProject?.projectId) {
        throw new Error('Project creation failed.');
      }

      StorageService.saveProject(createdProject);
      upsertProject(createdProject);

      const coverRef = String(createdProject.coverImageUrl || '').trim();
      const coverSignedUrl = String(createdProject.coverSignedUrl || '').trim();
      if (isAssetRef(coverRef) && coverSignedUrl) {
        setAssetUrls((prev) => ({ ...prev, [coverRef]: coverSignedUrl }));
      }

      navigate(`/dashboard/edit/${createdProject.projectId}`);
    } catch (err: any) {
      alert(err?.message || 'Unable to create album right now.');
    } finally {
      setIsCreatingProject(false);
    }
  };

  const handleDelete = async (id: string, e: React.MouseEvent) => {
    e.preventDefault();
    if (deletingProjectId === id) return;
    if (!confirm('Are you sure you want to delete this project?')) {
      return;
    }

    setDeletingProjectId(id);
    try {
      const token = getAdminToken();
      await Api.deleteProject(id, token);
      StorageService.deleteProject(id);
      setProjects((prev) => prev.filter((project) => project.projectId !== id));
    } catch (err: any) {
      const message = String(err?.message || '');
      if (message.toLowerCase().includes('project not found')) {
        StorageService.deleteProject(id);
        setProjects((prev) => prev.filter((project) => project.projectId !== id));
      } else {
        alert(message || 'Unable to delete album right now.');
      }
    } finally {
      setDeletingProjectId(null);
    }
  };

  return (
    <div className="max-w-5xl mx-auto px-6 py-12">
      <header className="flex flex-col md:flex-row md:items-center justify-between gap-6 mb-12">
        <div className="flex items-center gap-6">
          <div onClick={handleLogout} className="p-3 bg-slate-900 border border-slate-800 rounded-2xl text-slate-500 hover:text-red-400 cursor-pointer transition-colors" title="Logout Admin">
            <LogOut size={20} />
          </div>
          <div>
            <h1 className="text-3xl font-black tracking-tight text-white">Artist Dashboard</h1>
            <p className="text-slate-400">Secure distribution for your music.</p>
          </div>
        </div>
        <button
          onClick={handleCreateNew}
          disabled={isCreatingProject}
          className="flex items-center justify-center gap-2 bg-green-500 hover:bg-green-400 disabled:bg-green-500/70 text-black font-bold py-3 px-6 rounded-full transition-all shadow-lg shadow-green-500/20 disabled:cursor-wait"
        >
          {isCreatingProject ? <Loader2 size={20} className="animate-spin" /> : <Plus size={20} />}
          {isCreatingProject ? 'Creating...' : 'Create Private TAP'}
        </button>
      </header>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {projects.map((project) => (
          <AlbumCard
            key={project.projectId}
            project={project}
            coverSrc={resolveCoverSrc(project)}
            hasCoverReference={hasCoverReference(project)}
            onRetryCoverUrl={retryCoverUrl}
            onDelete={handleDelete}
          />
        ))}
        <CreateAlbumPlaceholderCard
          onCreate={handleCreateNew}
          loading={isCreatingProject || (projectsLoading && projects.length === 0)}
        />
      </div>
    </div>
  );
};

export default DashboardPage;
